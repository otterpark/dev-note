# 1. Redux 개요 및 개념

>💡 학습 내용
>
>- Redux란 무엇이며 왜 사용해야 하는가?
>- Redux의 주요 용어 및 개념
>- Redux 앱에서 데이터가 흐르는 방식

## redux란?

**Redux는 `액션`이라는 이벤트를 사용하여 애플리케이션 상태를 관리하고 업데잍트하기 위한 패턴 및 라이브러리**이다. 상태가 예측 가능한 방식으로만 업데이트될 수 있도록 하는 규칙과 함께 전체 애플리케이션에서 사용해야 하는 상태에 대한 중앙 집중식 저장소 역할을 합니다.

### 그럼 왜 사용해야 하나요?

Redux는 애플리케이션의 여러 부분에 필요한 상태인 `전역` 상태를 관리하는데 도움이 됩니다.

**Redux에서 제공되는 패턴과 도구를 사용하면 애플리케이션의 상태가 언제, 어디서, 왜, 업데이트 되는지 그리고 이러한 변경이 발생할 때 애플리케이션 로직이 어떻게 작동**하는지 더 쉽게 이해할 수 있습니다.

> 즉, Redux는 예측 가능하고 테스트 가능한 코드를 작성하도록 하므로, 애플리케이션이 예상대로 작동할 것이라는 확신을 가질 수 있다.

### 언제 사용해야 할까요?

Redux는 공유 상태 관리를 처리하는데 도움이 되지만 다른 도구와 마찬가지로 장단점이 있습니다. 배워야 할 개념과 작성해야할 코드가 많습니다(Redux Toolkit으로 어느정도 해결). Redux는 코드에 뱡향성을 추가하고 특정 제한 사항을 따르도록 요구합니다. 이는 단기적인 생산성과 장기적인 생산성 사이의 절충안입니다.

- 앱의 여러 곳에서 필요한 대량의 애플리케이션 상태가 있는 경우
- 앱 상태가 시간이 지남에 따라 자주 업데이트되는 경우
- 해당 상태를 업데이트하는 로직이 복잡할 수 있습니다.
- 앱에 중대형 코드베이스가 있고 많은 사람이 작업할 수 있는 경우

**모든 앱에 Redux가 필요한 것은 아닙니다. 시간을 내어 어떤 종류의 앱을 만들고 있는지 생각해보고 작업 중인 문제를 해결하는데 적합한 도구가 무엇인지 생각해야한다.**

### Redux에 대해 생각하는 방법

Redux는 일반적인 상태 관리 도구로 다양한 사용 사례에 사용할 수 있습니다.

- 서버에서 캐싱 상태
- UI 상태
- 클라이언트에서 기타 복잡한 데이터 관리

Redux는 다양한 작업을 할 수 있으나, 더 좋은 서버 캐싱을 할 수 있는 도구인 React Query, swr이 있습니다. 상황에 맞춰 라이브러리를 사용하는게 중요하다.

1. 어떤 구체적인 문제를 해결하려고 합니까?
2. 이러한 도구는 어떤 문제를 해결합니까?
3. 그 사이에 겹치는 부분은 어디입니까?

### Redux 라이브러리 및 도구

Redux는 일반적으로 다른 여러 패키지와 함께 사용되는 작은 독립형 JS 라이브러리입니다.

#### `React-Redux`

Redux는 모든 UI 프레임워크와 통합할 수 있으며, React와 함께 가장 자주 사용됩니다. React-Redux는 React 컴포넌트가 상태 조각을 읽고 액션을 전송하여 스토어를 업데이트함으로써 Redux 스토어와 상호 작용할 수 있게 해주는 공식 패키지입니다.

#### `Redux Toolkit`

Redux 툴킷은 Redux 로직을 작성하는 데 권장되는 접근 방식입니다. 여기에는 Redux 앱을 빌드하는 데 필수적이라고 생각되는 패키지와 함수가 포함되어 있습니다. Redux 툴킷은 권장 모범 사례를 기반으로 구축되며, 대부분의 Redux 작업을 간소화하고, 일반적인 실수를 방지하며, Redux 애플리케이션을 더 쉽게 작성할 수 있게 해줍니다.

#### `Redux 개발자 도구 확장`

Redux 개발자 도구 확장 프로그램은 시간 경과에 따른 Redux 저장소의 상태 변경 내역을 보여줍니다. 이를 통해 `"time-travel debugging"`과 같은 강력한 기술을 사용하는 등 애플리케이션을 효과적으로 디버깅할 수 있습니다.

## Redux 용어 및 개념

Redux를 사용하기 위해 알아야 할 몇 가지 용어와 개념에 대해 이야기 하려고 합니다.

### State Management

작은 React Counter 컴포넌트부터 살펴보겠습니다. 컴포넌트 상태에서 숫자를 추적하고 버튼이 클릭되면 숫자를 증가시킵니다.

```tsx
function Counter() {
  // State: 카운터 값
  const [counter, setCounter] = useState(0)

  // Action: 어떤 일이 발생하면 상태를 업데이트하는 코드입니다.
  const increment = () => {
    setCounter(prevCounter => prevCounter + 1)
  }

  // View: UI 정의
  return (
    <div>
      Value: {counter} <button onClick={increment}>Increment</button>
    </div>
  )
}
```

다음과 같은 부분으로 구성된 독립형 앱입니다.

- `상태` - 앱을 구동하는 진실의 원천
- `뷰` - 현재 상태를 기반으로 한 UI의 선언적 설명
- `액션` - 사용자 입력에 따라 앱에서 발생하는 이벤트이며 상태의 업데이트를 트리거

이것은 `"단방향 데이터 흐름"`의 작은 예입니다.

- `상태` - 특정 시점의 앱 상태를 설명합니다.
- `UI` - 해당 상태를 기반으로 렌더링됩니다.
- 어떤 일이 발생하면(예: 사용자가 버튼을 클릭), 발생한 일을 기반으로 상태가 업데이트됩니다.
- `UI` - 새로운 상태를 기반으로 다시 렌더링됩니다.

![one-way data flow](../img/one-way-data-flow.png)

그러나 **동일한 상태를 공유하고 사용해야 하는 여러 컴포넌트가 있는 경우**, 특히 해당 컴포넌트가 애플리케이션의 다른 부분에 있는 경우에는 단순성이 무너질 수 있습니다. 때로는 부모 컴포넌트로 `'상태 위로 올리기'`를 통해 이 문제를 해결할 수 있지만, 항상 도움이 되는 것은 아닙니다.

이 문제를 해결하는 한 가지 방법은 컴포넌트에서 공유 상태를 추출하여 컴포넌트 트리 외부의 중앙 집중식 위치에 저장하는 것입니다. 이렇게 하면 컴포넌트 트리가 하나의 큰 `"보기"`가 되고, 트리의 위치에 상관없이 모든 컴포넌트가 상태에 액세스하거나 동작을 트리거할 수 있습니다!

상태 관리와 관련된 개념을 정의 및 분리하고 뷰와 상태 간의 독립성을 유지하는 규칙을 적용함으로써 코드의 구조와 유지보수성을 강화할 수 있습니다.

애플리케이션의 전역 상태를 포함하는 단일 중앙 집중식 공간과 해당 상태를 업데이트할 때 따라야 할 특정 패턴을 통해 코드를 예측 가능하게 만드는 것이 바로 Redux의 기본 개념입니다.

### 불변성(Immutability)

불변"인 것은 절대 변경할 수 없습니다.

자바스크립트 객체와 배열은 기본적으로 모두 변경 가능합니다. 객체를 생성하면 해당 필드의 내용을 변경할 수 있습니다. 배열을 만들면 그 내용도 변경할 수 있습니다.

```tsx
const obj = { a: 1, b: 2 }
// 외부의 obj는 여전히 동일하지만 내용이 변경되었습니다.
obj.b = 3

const arr = ['a', 'b']
// 같은 방식으로 이 배열의 내용을 변경할 수 있습니다.
arr.push('c')
arr[1] = 'd'
```

이를 객체 또는 배열 변경이라고 합니다. 메모리에서 동일한 객체 또는 배열 참조이지만 이제 객체 내부의 내용이 변경되었습니다.

**값을 불변으로 업데이트하려면 코드에서 기존 객체/배열의 복사본을 만든 다음 복사본을 수정해야 합니다.**

이 작업은 자바스크립트의 배열/객체 확산 연산자와 원본 배열을 변경하는 대신 배열의 새 복사본을 반환하는 배열 메서드를 사용하여 직접 수행할 수 있습니다.

```tsx
const obj = {
  a: {
    // obj.a.c를 안전하게 업데이트하려면 각 obj를 복사해야 합니다.
    c: 3
  },
  b: 2
}

const obj2 = {
  // obj 복사
  ...obj,
  // a 덮어쓰기
  a: {
    // obj.a 복사
    ...obj.a,
    // c 덮어쓰기
    c: 42
  }
}

const arr = ['a', 'b']
// 끝에 "c"를 추가하여 arr의 새 복사본을 만듭니다.
const arr2 = arr.concat('c')

// 원본 배열의 복사본을 사용하여 만들 수 있습니다
const arr3 = arr.slice()
arr3.push('c')
```

**`Redux`는 모든 상태 업데이트가 불변으로 수행되기를 기대**합니다. 나중에 이것이 왜 중요한지, 어떻게 중요한지, 그리고 불변 업데이트 로직을 작성하는 몇 가지 쉬운 방법을 살펴보겠습니다.

## 용어(Terminology)

계속하기 전에 숙지해야 할 몇 가지 중요한 Redux 용어가 있습니다.

### 액션(Action)

액션은 `type` 필드가 있는 일반 JavaScript 객체입니다. 액션은 애플리케이션에서 발생한 일을 설명하는 이벤트라고 생각하면 됩니다.

`type` 필드는 `"todos/todoAdded"`과 같이 이 작업에 설명적인 이름을 부여하는 문자열이어야 합니다. 일반적으로 `"domain/eventName"`과 같은 유형 문자열을 작성하는데, 여기서 첫 번째 부분은 이 작업이 속한 기능 또는 카테고리이고 두 번째 부분은 발생한 구체적인 일입니다.

작업 개체에는 발생한 일에 대한 추가 정보가 포함된 다른 필드가 있을 수 있습니다. 관례에 따라 이러한 정보를 `payload`라는 필드에 넣습니다.

일반적인 액션 객체는 다음과 같이 보일 수 있습니다.

```tsx
const addTodoAction = {
  type: 'todos/todoAdded',
  payload: 'Buy milk'
}
```

### 액션 크리에이터(Action Creator)

액션 크리에이터는 액션 객체를 생성하고 반환하는 함수입니다. 일반적으로 매번 액션 객체를 직접 작성할 필요가 없도록 하기 위해 사용합니다.

```tsx
const addTodo = text => {
  return {
    type: 'todos/todoAdded',
    payload: text
  }
}
```

### 리듀서(Reducers)

리듀서는 현재 상태와 액션 객체를 수신하고, 필요한 경우 상태를 업데이트하는 방법을 결정한 후 새 상태를 반환하는 함수입니다. `(state, action) => newState`. **리듀서는 수신된 액션(이벤트) 유형에 따라 이벤트를 처리하는 이벤트 리스너라고 생각하면 됩니다.**

> "Reducer" 함수는 `Array.reduce()` 메서드에 전달하는 콜백 함수의 종류와 유사하기 때문에 이런 이름이 붙었습니다.

리듀서는 항상 몇 가지 특정 규칙을 따라야 합니다.

1. 상태 및 액션 인수를 기반으로 새 상태 값만 계산해야 합니다.
2. 기존 상태를 수정할 수 없습니다. 대신 기존 상태를 복사하고 복사된 값을 변경하는 방식으로 불변 업데이트를 수행해야 합니다.
3. 비동기 로직을 수행하거나 임의의 값을 계산하거나 기타 "부작용"을 일으키지 않아야 합니다.
4. 리듀서 규칙이 중요한 이유와 올바르게 따르는 방법 등 리듀서 규칙에 대해서는 나중에 자세히 설명하겠습니다.

리듀서 함수 내부의 로직은 일반적으로 동일한 일련의 단계를 따릅니다:

- 리듀서가 이 작업을 신경 쓰는지 확인합니다.
  - 그렇다면 상태의 복사본을 만들고 새 값으로 복사본을 업데이트한 후 반환합니다.
- 그렇지 않으면 기존 상태를 변경하지 않고 반환합니다.

다음은 각 리듀서가 따라야 하는 단계를 보여주는 리듀서의 작은 예시입니다.

```tsx
const initialState = { value: 0 }

function counterReducer(state = initialState, action) {
  // Reducer가 이 작업에 관심이 있는지 확인합니다.
  if (action.type === 'counter/increment') {
    // 만약 맞다면 `state`를 복사합니다.
    return {
      ...state,
      // 새 값으로 복사본을 업데이트합니다.
      value: state.value + 1
    }
  }
  // 조건에 안 맞다면 기존 상태를 변경하지 않고 반환합니다.
  return state
}
```

리듀서는 내부에서 `if/else`, `스위치`, `루프` 등 모든 종류의 로직을 사용하여 새 상태를 결정할 수 있습니다.

#### 💡 `reducers`라고 부르는 걸까요?

`Array.reduce()` 메서드를 사용하면 값 배열을 받아 배열의 각 항목을 한 번에 하나씩 처리하여 하나의 최종 결과를 반환할 수 있습니다. "배열을 하나의 값으로 줄이는 것"이라고 생각하면 됩니다.

`Array.reduce()`는 배열의 각 항목에 대해 한 번씩 호출되는 콜백 함수를 인수로 받습니다. 두 개의 인수를 받습니다.

- `previousResult`, 콜백이 지난번에 반환한 값
- `currentItem`, 배열의 현재 항목

콜백이 처음 실행될 때는 `previousResult`를 사용할 수 없으므로 첫 번째 `previousResult`로 사용할 초기 값도 전달해야 합니다.

숫자 배열을 합산하여 총합이 얼마인지 알아내려면 다음과 같은 감소 콜백을 작성할 수 있습니다.

```tsx
const numbers = [2, 5, 8]

const addNumbers = (previousResult, currentItem) => {
  console.log({ previousResult, currentItem })
  return previousResult + currentItem
}

const initialValue = 0

const total = numbers.reduce(addNumbers, initialValue)
// {previousResult: 0, currentItem: 2}
// {previousResult: 2, currentItem: 5}
// {previousResult: 7, currentItem: 8}

console.log(total)
// 15
```

`addNumbers` "reduce callback" 함수는 자체적으로 아무것도 추적할 필요가 없다는 점에 주목하세요. `previousResult` 와  `currentItem` 인수를 받아 어떤 작업을 수행한 후 새로운 결과 값을 반환합니다.

`Redux 리듀서 함수`는 이 "콜백 줄이기" 함수와 정확히 같은 개념입니다! "이전 결과"(상태)와 "현재 항목"(액션 객체)을 받아 해당 인수를 기반으로 새 상태 값을 결정한 후 새 상태를 반환합니다.

Redux 액션의 배열을 만들고 `reduce()`를 호출한 다음 감속기 함수를 전달하면 같은 방식으로 최종 결과를 얻을 수 있습니다.

```tsx
const actions = [
  { type: 'counter/increment' },
  { type: 'counter/increment' },
  { type: 'counter/increment' }
]

const initialState = { value: 0 }

const finalResult = actions.reduce(counterReducer, initialState)
console.log(finalResult)
// {value: 3}
```

`Redux 리듀서`는 **(시간이 지남에 따라) 일련의 액션을 단일 상태로 축소**한다고 말할 수 있습니다. 차이점은 `Array.reduce()`를 사용하면 한 번에 모든 작업이 수행되지만 `Redux`를 사용하면 실행 중인 앱의 수명 동안 작업이 수행된다는 점입니다.

### 상태(Store)

현재 Redux 애플리케이션 상태는 store 라는 객체에 저장됩니다.

store는 리듀서를 전달하여 생성되며, 현재 상태 값을 반환하는 `getState`라는 메서드가 있습니다.

```tsx
import { configureStore } from '@reduxjs/toolkit'

const store = configureStore({ reducer: counterReducer })

console.log(store.getState())
// {value: 0}
```

### 디스패치(Dispatch)

Redux 저장소에는 `dispatch`라는 메서드가 있습니다. store를 업데이트하는 유일한 방법은 `store.dispatch()`를 호출하고 액션 객체를 전달하는 것입니다. store는 리듀서 함수를 실행하고 새로운 상태 값을 저장하며, 우리는 `getState()`를 호출하여 업데이트된 값을 검색할 수 있습니다.

```tsx
store.dispatch({ type: 'counter/increment' })

console.log(store.getState())
// {value: 1}
```

`dispatching actions`을 애플리케이션에서 "이벤트 트리거"라고 생각할 수 있습니다. 어떤 일이 발생했고 상태에서 이를 알기를 원합니다. 리듀서는 이벤트 리스너처럼 작동하며, 관심 있는 액션을 수신하면 이에 대한 응답으로 상태를 업데이트합니다.

일반적으로 액션 크리에이터에게 올바른 액션을 전송하도록 요청합니다.

```tsx
const increment = () => {
  return {
    type: 'counter/increment'
  }
}

store.dispatch(increment())

console.log(store.getState())
// {value: 2}
```

### 셀렉터(Selectors)

셀렉터는 스토어 상태 값에서 특정 정보를 추출하는 방법을 알고 있는 함수입니다. 애플리케이션의 규모가 커지면 앱의 여러 부분에서 동일한 데이터를 읽어야 하므로 반복되는 로직을 피하는 데 도움이 될 수 있습니다.

```tsx
const selectCounterValue = state => state.value

const currentValue = selectCounterValue(store.getState())
console.log(currentValue)
// 2
```

## Redux 애플리케이션 데이터 흐름

앞서 앱을 업데이트하는 일련의 단계를 설명하는 '단방향 데이터 흐름'에 대해 이야기했습니다.

- 상태는 특정 시점의 앱 상태를 설명합니다.
- UI는 해당 상태를 기반으로 렌더링됩니다.
- 어떤 일이 발생하면(예: 사용자가 버튼을 클릭), 발생한 일을 기반으로 상태가 업데이트됩니다.
- UI는 새로운 상태를 기반으로 다시 렌더링됩니다.

Redux의 경우 이러한 단계를 더 자세히 나눌 수 있습니다.

- `초기 설정`
  - 루트 리듀서 함수를 사용하여 Redux store를 생성합니다.
  - 스토어는 루트 리듀서를 한 번 호출하고 반환값을 초기 상태로 저장합니다.
  - UI가 처음 렌더링될 때 UI 컴포넌트는 Redux 저장소의 현재 상태에 액세스하고 해당 데이터를 사용하여 렌더링할 내용을 결정합니다. 또한 향후 스토어 업데이트를 구독하여 상태가 변경되었는지 알 수 있습니다.

- `업데이트`
  - 사용자가 버튼을 클릭하는 등 앱에서 어떤 일이 발생합니다.
  - 앱 코드는 dispatch({유형: '카운터/증가'})와 같이 Redux 스토어에 액션을 디스패치합니다.
  - 스토어는 이전 상태와 현재 액션으로 감속기 함수를 다시 실행하고 반환값을 새 상태로 저장합니다.
  - 스토어는 구독된 UI의 모든 부분에 스토어가 업데이트되었음을 알립니다.
  - 스토어의 데이터가 필요한 각 UI 컴포넌트는 필요한 상태의 일부가 변경되었는지 확인합니다.
  - 데이터가 변경된 것을 확인한 각 컴포넌트는 새 데이터로 강제로 다시 렌더링하여 화면에 표시되는 내용을 업데이트할 수 있습니다.

![Redux Data Flow](../img/redux-data-flow.gif)
